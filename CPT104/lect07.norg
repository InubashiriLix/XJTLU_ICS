* 7.1 虚拟内存 背景
  - 虚拟内存（VM）将用户的逻辑地址空间与物理内存分离  
  - 只需将正在执行的程序部分加载到内存中，其余保存在磁盘上的交换区（swap space）  
  - 程序在内存中驻留的部分称为该进程的常驻集（resident set）  
  - 必须支持页面或段在内存与磁盘间的置换（swap in/out）  
  - 虚拟内存系统由两部分构成  
  - 硬件：内存管理单元（MMU），负责地址转换  
  - 软件：虚拟内存处理程序（VM handler），负责置换算法、页面表管理等  

* 7.2 需求分页 Demand Paging
  - 只在首次访问时才将页从磁盘调入内存  
  - 如果某页从未被访问，则永远不加载（lazy swapper，仅在需要时才换入）  

* 7.2.1 实现中的关键问题
  - 如何判断页是否在内存中？  
  - 使用页表中“有效-无效”位  
  - valid=1：页在内存且地址合法  
  - valid=0：页不在内存或地址非法  
  - 访问不在内存中的页时会发生什么？  
  - CPU 通过页表发现 invalid 位，触发缺页异常（page fault）  
  - 如果没有空闲帧怎么办？  
  - 必须执行页面替换，选出被牺牲页，必要时写回磁盘，然后回收帧  
  - 哪个页被替换？  
  - 由页面替换算法决定（FIFO、LRU、Clock 等）  

* 7.2.2 缺页中断处理步骤
  1. CPU 访问逻辑地址，查询页表发现 valid=0，触发缺页异常  
  2. CPU 保存当前进程上下文，转入操作系统内核  
  3. 操作系统检查页号是否超出该进程的逻辑地址空间  
  - 超出则终止进程并报告错误  
  - 否则继续  
    4. 操作系统在“空闲帧列表”中取出一个帧  
  - 若列表为空，执行页面替换：  
    1) 选择替换页  
    2) 若该页被修改，则写回磁盘（page‑out）  
    3) 更新其页表项 valid=0  
    4) 回收其帧号  
    5. 将缺失页从交换区调入所选帧（page‑in）  
    6. 更新缺页页表项：  
  - 设置 valid=1  
  - 写入新帧号  
    7. 恢复被中断进程的上下文，重启引起缺页的指令  

* 7.2.2 需求分页 性能评估
  - 无缺页时  
  - 有效访问时间（EAT） = 内存访问时间（MAT）
  - 有缺页时  
  - 设 p 为发生缺页的概率  
  - EAT = (1 - p) × MAT + p × PageFaultServiceTime  
  - 缺页服务时间主要包含  
  - 处理缺页中断  
  - 将所需页从换出区读入内存（page‑in）  
  - 重启导致缺页的指令  

* 7.3 写时复制（Copy‑On‑Write, COW）
  - 在 fork() 创建子进程时，父子进程初始共享所有页  
  - 只有当某个进程首次对共享页进行写操作时，才复制该页并分配新的帧  
  - 优点：避免了 fork 后立即复制整个页表，节省内存与 I/O  

* 7.4 页面替换
  - 当 free‑frame 列表为空且发生缺页时，需要选出一个已在内存的页（牺牲页）进行替换  
  - 目标  
  - 保持低缺页率：将热点页留在内存  
  - 降低缺页延迟：优先替换未被修改（dirty bit=0）的页，减少写回开销  
  - 基本步骤  
    1. 查找目标页在磁盘上的位置  
    2. 若有空闲帧，则直接使用；否则调用页面替换算法选出牺牲帧  
    3. 若牺牲页 dirty bit=1，写回磁盘（page‑out）  
    4. 将新页读入该帧，更新页表与帧表  
    5. 重启导致缺页的指令  

** 7.4.1 先进先出（FIFO）算法
   - 替换最早进入内存、存留时间最长的页  
   - 简单易实现，但可能出现 Belady’s anomaly  

** 7.4.2 最佳（Optimal）算法
   - 替换在未来最长时间内不会被访问的页  
   - 理论上最优，但需预知未来访问序列，无法实现  

** 7.4.3 最近最少使用（LRU）算法
   - 替换最长时间未被访问的页  
   - 实现方式  
   - 计数器法：每个页表项维护访问时间戳  
   - 栈式法：每次访问将页移至栈顶，栈底页为最久未用  
** 7.4.4 LRU 近似算法
   - 为每个页表项维护一个引用位（reference bit）
   - 硬件在页被访问（读或写）时将其引用位置 1
   - 操作系统定期清零所有引用位，以近似实现 LRU

** 7.4.5 二次机会（Clock）算法
   - 将内存中的帧组织成一个环形链表，指针指向上次检查的位置
   - 选帧时检查当前指针对应页的引用位
   - 若 = 1，则将其清零并将指针移至下一个帧（给予“第二次机会”）
   - 若 = 0，则选择该帧作为牺牲页

** 7.4.6 计数算法
   - 为每个页维护一个访问计数器
   - 最不常用 (LFU)：替换访问计数最小的页
   - 最常用 (MFU)：替换访问计数最大的页（假设刚调入的页通常不常使用）

* 7.5 帧分配
- 平等分配（Equal allocation）
  - 系统有 m 个帧、n 个进程，每个进程分配 ⌊m/n⌋ 或 ⌈m/n⌉ 个帧
- 比例分配（Proportional allocation）
  - 设进程 pi 的大小为 si，总和 S = Σ si，总帧数 m  
  - 则分配给 pi 的帧数 ai = (si / S) × m
- 抖动（Thrashing）
  - 进程因频繁缺页而忙于调入调出，无法进行有效计算  
  - 导致 CPU 利用率低  
  - 操作系统误以为需要增加多道程序度，继续加入新进程，加剧抖动  


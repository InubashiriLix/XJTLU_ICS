* 6 内存管理基础
** 6.1 MMU
- CPU 产生虚拟地址 → MMU 转换为物理地址
- 所有内存引用必须经过 MMU

** 6.1.1 内存管理需求
- 保护 Protection
  - 操作系统与用户进程隔离
  - 进程之间隔离
  - 依赖硬件界限寄存器或页表标志
- 重定位 Relocation
  - 进程可在内存任意位置运行
  - MMU 在发送到内存前：物理地址 = 重定位寄存器 + 逻辑地址
- 共享 Sharing
  - 多进程可映射同一物理页实现共享
  - 通过读写权限位保证安全
- 逻辑组织 Logical Organization
  - 线性地址空间：Text / Data / Heap / Stack
- 物理组织 Physical Organization
  - DRAM：快但贵
  - 次级存储：慢但容量大，用于交换或分页

** 6.1.2 Base–Limit 机制
- Base 寄存器：进程可访问的起始物理地址
- Limit 寄存器：进程地址空间大小
- 地址检查
  - 若逻辑地址 < Limit
    - 物理地址 = Base + 逻辑地址
  - 否则陷入内核触发地址错误

** 6.2 Contiguous Memory Allocation
*** 6.2.1 CONTIGUOUS ALLOCATION
**** 固定分区  Fixed / Static Partitioning
     - 物理内存在启动时被划分为若干固定分区（可等大也可不等大）
     - 进程只能装入其大小不超过且最接近的分区
     - 优点：实现简单、地址连续
     - 缺点：容易产生内部碎片；分区数与大小在运行期不可改变

**** 可变分区  Variable / Dynamic Partitioning
     - 内核维护“空闲区表”记录所有空洞（hole）
     - 当有进程装入，查表寻找足够大的空洞并分配
***** 空洞选择策略
      - First‑fit  ：遍历空闲区，遇到第一块足够大的就分配
      - Best‑fit   ：在所有足够大的空洞中选“最小但足够”的那块
      - Worst‑fit  ：总是把最大的空洞分出去，留下较大的剩余

*** 6.2.2 Fragmentation
**** 内部碎片  Internal Fragmentation
     - 发生于固定分区：最后一页（分区）未被进程完全填满
     - 解决：改用可变分区或更小分区粒度

**** 外部碎片  External Fragmentation
     - 发生于可变分区：频繁装入 / 释放后留下大量零散小孔
***** 典型缓解方法
      - Compaction：把所有已占用块搬移到内存一端，形成一个大孔
      - 非连续分配：采用分段 Segmentation 或分页 Paging，将进程地址空间拆分映射，根本避免外部碎片

** 6.3 非连续内存分配（Segmentation & Paging）
*** 6.3.1 分段  Segmentation
    - 程序被逻辑划分为段：如代码段、数据段、栈段
    - 逻辑地址 = <段号 s, 段内偏移 d>
    - 段表项
    - base : 段在物理内存中的起始地址
    - limit: 段长度
    - 地址转换流程
      1. 取段号 s 查段表，得到 base 与 limit
      2. 若 d < limit 则物理地址 = base + d，否则触发越界异常
    - 优点：符合程序逻辑、易于共享和动态链接
    - 缺点：外部碎片；段表可能很大

*** 6.3.2 分页  Paging
    - 物理内存分为固定大小帧 frame，逻辑空间同样划分为页 page
    - 页大小通常 512B – 1GiB，为 2^n
    - 逻辑地址 = <页号 p, 页内偏移 d>
    - 物理地址 = frame_number × page_size + d
    - 页表：将页号 p 映射到帧号 f
    - 两次内存访问问题 → 使用 TLB 加速

*** 6.3.3 TLB（Translation Lookaside Buffer）
    - 硬件联想缓存，存放最近使用的页表项
    - 命中: 只需一次内存访问
    - 未命中: 访问主存页表后写回 TLB
    - 命中率 A, 访问时间 E, 主存访问 M
    - EAT = A(E+M)+(1−A)(E+2M)

*** 6.3.4 分段 vs 分页
    - 目的
    - 分段：满足用户的逻辑视图
    - 分页：解决外部碎片、提高内存利用
    - 长度
    - 段大小可变
    - 页大小固定
    - 地址空间
    - 段：二维 <段号, 偏移>
    - 页：一维 <页号, 偏移>
    - 碎片
    - 分段：有外部碎片无内部碎片
    - 分页：有内部碎片无外部碎片
    - 共享
    - 分段更易实现按逻辑单元共享

*** 6.3.5 内存保护
    - 每帧带保护位 R/W/X
    - 有效位 Valid/Invalid 标识地址是否属于进程逻辑空间

*** 6.3.6 页共享
    - 只读代码可被多个进程映射到同一帧
    - 数据页各自映射不同帧，代码共享节省内存

*** 6.3.7 大型页表结构
    - 二级页表（Hierarchical Paging）
    - 虚拟地址拆成 p1 | p2 | d
    - 先取一级页表 p1 得到二级页表基址，再取 p2 得帧号
    - 哈希页表（Hashed Page Table）
    - 适用于 32 位以上地址
    - 将页号哈希到桶，桶内链表存放元素 (page, frame, next)
    - 反向页表（Inverted Page Table）
    - 每个物理帧对应一项：<进程ID, 虚拟页号>
    - 通过 TLB 减少查找成本

*** 6.3.8 实现注意
    - PTBR 保存当前进程页表基址
    - 进程切换时内核更新 PTBR、清空或标记 TLB


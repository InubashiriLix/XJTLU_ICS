* Deteerministic Finite Automata (DFA)
** definition
DFA is defined as a 5-tuple:
M = (Q, Œ£, Œ¥, q, F)
- Q is a finite set of states.
  states of a machines tells you somthing about hte prefix that has been read so far, 
  if hte string is a member of language of interset, 
  the state reached whem the whole string has been scanned will be an accepting state.
- Œ£ is a finite set of symbols, called the alphabet of automata.
- Œ¥: Q x Œ£ -> Q is a function, called the transition function.
  transition function Œ¥ tell you how state should change when an additional letter is read by DFA.
- q ‚àà Q is called the initial state.
- F ‚äÜ Q is a set of accepting/terminal states.
- the DFA is *deterministic* because for each state and input symbol, because
  the next state the machine goes to on any givene symbol is uniquely determined.
- that is, DFA has exactly one transition leaving each state for each symbol.
** transition function
sence the example below, 
we can extend the definition of the transition function ùõø
so that is tells us which state we reach after a word (not just a single letter has been scanned):
extend the map 
ùõø: Q x Œ£ -> Q  =>  ùõø*: Q x Œ£* -> Q
by defining: 
- ùõø*(q,œµ) = q               for all q ‚àà Q
- ùõø*(q,wa) = Œ¥(Œ¥*(q,w),ùëé)   for all q ‚àà Q; w ‚àà Œ£*; a ‚àà Œ£;
explanation:
- ùõø*(q,œµ) = q:
  if input is empty, then the state will not change;
- ùõø*(q,wa) = Œ¥(Œ¥*(q,w),ùëé): 
  wa: w is the prefix of wa, a is the postfix of wa, 
  if you concat the w and a together as the input,
  the DFA will read w first, update the state, then read the 'a' and update the state

*** Example of transition function
initiallly the state is i and if the input word is w = a1, a2, a3, ..., an then
as each letter is read, the state changes and we get q1 q2 qn defined by
- q1 = ùõø(i, a1)
- q2 = ùõø(q1, a2)
- q3 = ùõø(q2, a3)
- q4 = ùõø(q3, a4)
- ...
- qn = ùõø(q.n-1, an)
noted that the initial state i: i ‚àà Q
after each word input, the changed is based on last state of DFA

*** Example of ùõø*(q,wa) = Œ¥(Œ¥*(q,w),ùëé):
**** Given 'a' and 'b' in the sigma Œ£
- q1 = ùõø(q0, a)
- q2 = ùõø(q1, b)
then: 
ùõø*(q0, ab) = q2
**** Proof steps:
formula:
- ùõø*(q0, ab) = ùõø(ùõø*(q0, a), b)
- ùõø*(q0, a) = ùõø(q0, a) = q1
=> Œ¥* (q0, ùëéb) =Œ¥(q1, b) = q2
** Transition Graph
A DFA M = (Q, Œ£, Œ¥, q, F) is often depicted as a directed graph G·¥π, called (*transition graph*)
G·¥π has exactly |Q| vertices, each one labelled with a different q·µ¢‚àà Q
for each transition function Œ¥(q·µ¢,a) = q‚±º, the graph has edges (q·µ¢, q‚±º) labelled with (a), (b), and (a, b).
The vertex associated with q‚ÇÅ is aclled the *initial vertex*, while those labeled with q·∂† are the *final vertices*
be brief:
- Gm: Transition Graph of DFA M
- Gm has |Q| vertices
- each vertex is labelled with different state q·µ¢ ‚àà Q
- each vertex has edges based on transition function Œ¥(q·µ¢,Sigma element) = q‚±º
- has final states q·∂† as final vertices
[[file:./statics/graphics/DFA/TransitionGraphExample.png]]
** Acceptance of strings in DFA
Let M =(Q, Œ£, Œ¥, q, F) be a finite automaton and let w = w0 w1 . . . wn be a string over
Define the sequence q0, q1, ... qn of states, in the following way:
- q0 = q,
- q·µ¢‚Çä‚ÇÅ = Œ¥(q·µ¢, w·µ¢‚Çä‚ÇÅ) for i = 0, 1, ..., n-1
1. if qn ‚àà F, then we say that M *accepts* the string w
2. if qn ‚àâ F, then we say that M *rejects* the string w

** Symbolic description of exmaple DFA
*** no partial transition function
[[file:./statics/graphics/DFA/SymbolicDescriptionDFA.png]]
set of state Q {i, t, r}, Œ£ = {0, 1}, F = {t} and the transition function Œ¥ is given
- Œ¥(i, 0) = r, Œ¥(i, 1) = t
- Œ¥(t, 0) = t, Œ¥(t, 1) = t
- Œ¥(r, 0) = r, Œ¥(r, 1) = r 
  we can describe it by table
  |   | 0 | 1 |
  |---+---+---|
  | i | r | t |
  | t | t | t |
  | r | r | r |
*** partial transition fucntion
if delta Œ¥ is a partial function (not defined for some state/letter pairs),
then the DFA rejects an input if it ever encounter such a pair
be like
|   | 0 | 1 |
|---+---+---|
| i |   | t |
| t | t | t |
** Language defined by DFA
the set of al words accepted by DFA M is called the language accepted by M
and will be denoted by L(M). Thus
L(M) = {w ‚àà Œ£*: Œ¥*(q0, w) ‚àà F}

and some additional notes:
- Any finite language is acceepted by some DFA
  that is, if a language is finite, then there must be a DFA that accepts it
- A language is called regular, 
  if there exists a finite automaton M such that A = L(M)
  that is, if a language (string set) can be accpted by a DFA, then it is a regular language

*** Example:
A = {w: w is a bindary string containing an odd number of 1s}
-----
the DFA can be defined as:
Q = {qo, qe}, F = {qo}, q = qe, Œ£ = {0, 1}
Œ¥'s symbolic description is:
|    | 0  | 1  |
| -- | -- | -- |
| qo | qo | qe |
| qe | qe | qo |
** Regular operations on languages
let A and B be two languages over the same alphabet.
- the union of A and B is defined as:
  A ‚à™ B = {w: w ‚àà A or w ‚àà B}
- the concatenation of A and B is defined as:
  AB = {ww': w ‚àà A and w' ‚àà B}
- the star of A is defined as:
  A* =  {u‚ÇÅu‚ÇÇ...u‚Çñ : k ‚â• 0 and u·µ¢‚àà A for all i = 1, 2, ..., k}
- noted that you can consider the language as the set of strings
*** Example:
A = {0, 01}
B = {1, 10}
A ‚à™ B = {0, 01, 1, 10}
AB = {01, 010, 011, 0110}
A* = {œµ, 0, 01, 00, 001, 010, 0101, ...}
** Theorem: Closure of Regular Languages under Union
The set of regular languages is closed under the union operation.
i.e. if A and B are regular languages over the same alphabet Œ£, 
then A ‚à™ B is also a *regular language* over Œ£.

** Exercise
*** exe1
how about the fllowing infinite language, Can you give a DFA that accepts the words:
bad, baad, baaad, baaaad, ...?
**** sol
ez.
Q = {q0, q1, q2}, F = {q2}, q = q0, Œ£ = {a, b}
|    | a  | b  |
|----+----+----|
| q0 |    | q1 |
| q1 | q1 | q2 |
*** exe2
Given the symbolic desxccription of a DFA, can you draw its corresponding diagram?
| Œ¥ | a  | b  | c  |
| -- | -- | -- | -- |
| Q1 | Q2 | Q1 | Q3 |
| Q2 | Q4 | Q1 | Q2 |
| Q3 | Q2 | Q3 | Q1 |
| Q4 | Q4 | Q2 | Q3 |
**** sol
[[file:./statics/graphics/DFA/Exe2Diagram.png]]
*** Exe3
Show that the language L is regular:
L = {awa: w ‚àà {a, b}*}
can you design a DFA that accepts L?
**** note:
how to understand this lang?
- the first and last letter must be 'a'
- the w can be a, b, or empty
- at least two chars
- for example: aa, aba, abba, ababa, abbbbaa ...
  and string like a, abb, ab, should be rejected
**** sol
hard =(
Q = {p0, p1, pA, pB, pd}
F = {pA}
q = p0
Œ£ = {a, b}
|    | a  | b  |
| -- | -- | -- |
| p0 | p1 | pd |
| p1 | pA | pB |
| pA | pA | pB |
| pB | pA | pB |
| pd | pd | pd |
M = (Q, Œ£, Œ¥, q, F)

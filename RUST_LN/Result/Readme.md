# ğŸš‰ ç¬¬ 5 è¯¾ï¼š`Result` â€”â€” ä¸ throwï¼Œä½†æ›´è¯šå®

## ä¸€å¥è¯ç»“è®ºï¼ˆå…ˆè®°ï¼‰

> **`Result` ä¸æ˜¯å¼‚å¸¸ï¼Œæ˜¯â€œå‡½æ•°ç­¾åé‡Œå†™æ¸…æ¥šï¼šæˆ‘å¯èƒ½å¤±è´¥â€ã€‚**

```rust
Result<T, E>
```

* `Ok(T)`ï¼šæˆåŠŸï¼Œæ‹¿åˆ°ç»“æœ
* `Err(E)`ï¼šå¤±è´¥ï¼Œç»™å‡ºåŸå› 

---

## 1ï¸âƒ£ ä¸ºä»€ä¹ˆ Rust ä¸ç”¨å¼‚å¸¸ï¼ˆthrowï¼‰

å› ä¸ºå¼‚å¸¸æœ‰ 3 ä¸ªå·¥ç¨‹çº§å¤§å‘ï¼š

1. **çœ‹ä¸åˆ°**ï¼šå‡½æ•°ç­¾åä¸è¯´ä¼šä¸ä¼šç‚¸
2. **ä¸å¥½ç»„åˆ**ï¼šåµŒå¥— try/catch è¯»ä¸ä¸‹å»
3. **æ§åˆ¶æµéšå¼**ï¼šä½ ä¸çŸ¥é“å“ªè¡Œä¼šè·³èµ°

Rust çš„é€‰æ‹©æ˜¯ï¼š

> âŒ è®©é”™è¯¯â€œé£â€
> âœ… è®©é”™è¯¯â€œå†™åœ¨ç±»å‹é‡Œâ€

---

## 2ï¸âƒ£ æœ€å°å¯ç”¨ç¤ºä¾‹ï¼ˆä½ é©¬ä¸Šå°±æ‡‚ï¼‰

### ä»å­—ç¬¦ä¸²è§£ææ•´æ•°

```rust
fn parse_i32(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(v) => Ok(v),
        Err(_) => Err(format!("cannot parse '{}'", s)),
    }
}
```

è°ƒç”¨æ–¹**å¿…é¡»**å¤„ç†ï¼š

```rust
match parse_i32("123") {
    Ok(v) => println!("value = {}", v),
    Err(e) => println!("error: {}", e),
}
```

ğŸ‘‰ **ç¼–è¯‘å™¨é€¼ä½ é¢å¯¹å¤±è´¥**ã€‚

---

## 3ï¸âƒ£ `?` è¿ç®—ç¬¦ï¼šæŠŠé”™è¯¯â€œå¾€ä¸Šæ‰”â€ï¼ˆä½†ä¸æ˜¯å¼‚å¸¸ï¼‰

ä½ å¾ˆå¿«ä¼šçœ‹åˆ°è¿™ç§å†™æ³•ï¼š

```rust
fn parse_i32(s: &str) -> Result<i32, String> {
    let v = s.parse::<i32>()
        .map_err(|_| format!("cannot parse '{}'", s))?;
    Ok(v)
}
```

### `?` çš„äººè¯è§£é‡Šæ˜¯

> â€œå¦‚æœè¿™é‡Œæ˜¯ `Err`ï¼Œ
> ğŸ‘‰ ç«‹åˆ»è¿”å›è¿™ä¸ª Err
> ğŸ‘‰ å¦åˆ™ç»§ç»­ç”¨é‡Œé¢çš„å€¼â€

ç­‰ä»·äºä½ æ‰‹å†™çš„ï¼š

```rust
match something {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```

---

## 4ï¸âƒ£ `Option` vs `Result`ï¼ˆä¸€å®šè¦åˆ†æ¸…ï¼‰

| ç±»å‹             | ä»€ä¹ˆæ—¶å€™ç”¨        |
| -------------- | ------------ |
| `Option<T>`    | **æ²¡æœ‰æ˜¯æ­£å¸¸æƒ…å†µ**  |
| `Result<T, E>` | **å¤±è´¥éœ€è¦è§£é‡ŠåŸå› ** |

### ä¾‹å­

```rust
fn find_user(id: i32) -> Option<User>        // æ‰¾ä¸åˆ°å¾ˆæ­£å¸¸
fn read_file(path: &str) -> Result<String>  // å¤±è´¥å¿…é¡»è¯´åŸå› 
```

---

## 5ï¸âƒ£ åˆ«å† `unwrap()`ï¼ˆé™¤éä½ å¾ˆç¡®å®šï¼‰

```rust
let v = s.parse::<i32>().unwrap(); // ğŸ’£
```

è¿™è¡Œä»£ç çš„çœŸå®å«ä¹‰æ˜¯ï¼š

> â€œå¦‚æœå¤±è´¥ï¼Œæˆ‘é€‰æ‹©**ç›´æ¥ç‚¸è¿›ç¨‹**ã€‚â€

å·¥ç¨‹é‡Œå¯ä»¥æ¥å—çš„ unwrap åœºæ™¯åªæœ‰ï¼š

* æµ‹è¯•
* demo
* æ˜ç¡®ä¸å¯èƒ½å¤±è´¥çš„åœ°æ–¹

---

# âœï¸ æœ¬è¯¾å®æˆ˜ç»ƒä¹ ï¼ˆçŸ­ï¼Œä½†å«é‡‘é‡æé«˜ï¼‰

## ç»ƒä¹  1ï¼ˆæ ¸å¿ƒï¼‰

å®ç°ä¸€ä¸ªè§£æç‚¹çš„å‡½æ•°ï¼š

```rust
fn parse_point(s: &str) -> Result<Point, String>
```

è¦æ±‚ï¼š

* è¾“å…¥æ ¼å¼ï¼š`"3.5,4.2"`
* æˆåŠŸï¼šè¿”å› `Point { x, y }`
* å¤±è´¥ï¼šè¿”å›**å¯è¯»çš„é”™è¯¯ä¿¡æ¯**

æç¤ºæ­¥éª¤ï¼ˆæŒ‰é¡ºåºåšï¼‰ï¼š

1. ç”¨ `split(',')`
2. æ‹¿åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²
3. `parse::<f64>()`
4. ç”¨ `?` ä¼ é€’é”™è¯¯

---

## ç»ƒä¹  2ï¼ˆç»„åˆ Resultï¼‰

å†™ä¸€ä¸ªå‡½æ•°ï¼š

```rust
fn distance_from_str(a: &str, b: &str) -> Result<f64, String>
```

* å†…éƒ¨è°ƒç”¨ `parse_point(a)?`
* å†…éƒ¨è°ƒç”¨ `parse_point(b)?`
* è¿”å›æ¬§æ°è·ç¦»

---

## ç»ƒä¹  3ï¼ˆæ€è€ƒé¢˜ï¼Œå†™ä¸€å¥è¯ï¼‰

å›ç­”è¿™å¥ï¼ˆç”¨ä½ è‡ªå·±çš„è¯ï¼‰ï¼š

> **ä¸ºä»€ä¹ˆ `Result` æ¯”å¼‚å¸¸æ›´é€‚åˆç³»ç»Ÿçº§è¯­è¨€ï¼Ÿ**

---

## ğŸ§  ä½ ç°åœ¨å·²ç»åˆ°å“ªä¸€æ­¥äº†ï¼ˆå¾ˆé‡è¦ï¼‰

ä½ å·²ç»ä¼šï¼š

* æ‰€æœ‰æƒ / å€Ÿç”¨
* `struct / enum / match`
* `impl + &self / &mut self`
* `Option`
* `Vec + iterator`
* **`Result`ï¼ˆè¿™èŠ‚è¿‡äº†å°±é½äº†ï¼‰**

ğŸ‘‰ å†å¾€ä¸‹å°±ä¸æ˜¯â€œRust è¯­æ³•â€ï¼Œè€Œæ˜¯ï¼š

* trait è®¾è®¡
* é”™è¯¯ç±»å‹è®¾è®¡
* API è®¾è®¡é£æ ¼
* å·¥ç¨‹å®è·µ
